Hereâ€™s a **detailed technical explanation** of how **Selection Sort, Insertion Sort, Bubble Sort, Merge Sort, and Quick Sort** workâ€”each with **example, dry-run, and internal logic**.

---

## 1. **Selection Sort**

### ğŸ’¡ **Working Principle:**

Select the minimum element and place it at the correct position.

### ğŸ“ˆ Time Complexity:

* Worst, Avg, Best: **O(nÂ²)**
* Space: **O(1)** (in-place)

### ğŸ” Algorithm:

1. For each index `i` from `0 to n-1`:
2. Find the minimum element from `i` to `n-1`
3. Swap it with the element at `i`

### ğŸ§  Dry-Run (Example: `[64, 25, 12, 22, 11]`):

```
Pass 1:
Find min from index 0 to 4 => 11, swap with 64
â†’ [11, 25, 12, 22, 64]

Pass 2:
Find min from index 1 to 4 => 12, swap with 25
â†’ [11, 12, 25, 22, 64]

Pass 3:
Find min from index 2 to 4 => 22, swap with 25
â†’ [11, 12, 22, 25, 64]

Pass 4:
Find min from index 3 to 4 => 25, already in place
â†’ [11, 12, 22, 25, 64]
```

---

## 2. **Insertion Sort**

### ğŸ’¡ **Working Principle:**

Insert the current element into its correct position in the **sorted left side**.

### ğŸ“ˆ Time Complexity:

* Worst: **O(nÂ²)** | Best: **O(n)** (already sorted)
* Space: **O(1)** (in-place)

### ğŸ” Algorithm:

1. Start from index 1, iterate to `n-1`
2. Compare current element (`key`) with previous elements
3. Shift all elements greater than key one position to right
4. Insert key in the correct place

### ğŸ§  Dry-Run (Example: `[64, 25, 12, 22, 11]`):

```
Start from index 1 (25):
â†’ Compare 25 < 64 â†’ shift 64
â†’ Insert 25 â†’ [25, 64, 12, 22, 11]

Index 2 (12):
â†’ Shift 64, 25
â†’ Insert 12 â†’ [12, 25, 64, 22, 11]

Index 3 (22):
â†’ Shift 64, 25
â†’ Insert 22 â†’ [12, 22, 25, 64, 11]

Index 4 (11):
â†’ Shift 64, 25, 22, 12
â†’ Insert 11 â†’ [11, 12, 22, 25, 64]
```

---

## 3. **Bubble Sort**

### ğŸ’¡ **Working Principle:**

Repeatedly swap adjacent elements if they are in the wrong order.

### ğŸ“ˆ Time Complexity:

* Worst & Avg: **O(nÂ²)** | Best: **O(n)** (optimized version)
* Space: **O(1)**

### ğŸ” Algorithm:

1. Traverse from 0 to `n-1`
2. Compare adjacent elements
3. Swap if theyâ€™re in the wrong order
4. Largest bubbles to the end each pass

### ğŸ§  Dry-Run (Example: `[64, 25, 12, 22, 11]`):

```
Pass 1:
â†’ [25, 12, 22, 11, 64]
Pass 2:
â†’ [12, 22, 11, 25, 64]
Pass 3:
â†’ [12, 11, 22, 25, 64]
Pass 4:
â†’ [11, 12, 22, 25, 64]
```

---

## 4. **Merge Sort**

### ğŸ’¡ **Working Principle:**

Divide the array into halves, recursively sort them, then merge the sorted halves.

### ğŸ“ˆ Time Complexity:

* All cases: **O(n log n)**
* Space: **O(n)** (uses temp arrays)

### ğŸ” Algorithm:

1. Divide array into two halves
2. Recursively sort the two halves
3. Merge them in sorted order

### ğŸ§  Dry-Run (Example: `[64, 25, 12, 22, 11]`):

```
Split: [64, 25] and [12, 22, 11]
â†’ Sort [64, 25] â†’ [25, 64]
â†’ Sort [12, 22, 11] â†’ 
   - Split [12] & [22,11]
   - Sort [22,11] â†’ [11,22]
   - Merge: [12,11,22] â†’ [11,12,22]
Merge [25,64] and [11,12,22] â†’ [11,12,22,25,64]
```

### ğŸ§© Merge Function Logic:

Merge two sorted arrays using two pointers.

---

## 5. **Quick Sort**

### ğŸ’¡ **Working Principle:**

Choose a pivot, partition array into twoâ€”left < pivot, right > pivot, and recurse.

### ğŸ“ˆ Time Complexity:

* Best & Avg: **O(n log n)**
* Worst: **O(nÂ²)** (if pivot is always max/min)
* Space: **O(log n)** (stack space)

### ğŸ” Algorithm:

1. Choose a pivot (commonly last or random)
2. Partition array:

   * Elements < pivot on left
   * Elements > pivot on right
3. Recursively sort both sides

### ğŸ§  Dry-Run (Example: `[64, 25, 12, 22, 11]`, pivot = 11):

```
Initial: [64, 25, 12, 22, 11]
â†’ Partition: move elements < 11 to left
â†’ [11, 25, 12, 22, 64] with pivot at index 0

Recur on [25, 12, 22, 64] â†’ pivot = 64
â†’ Already sorted relative to 64

Now recur on [25, 12, 22]:
â†’ pivot = 22 â†’ [12, 22, 25]
Final: [11, 12, 22, 25, 64]
```

### ğŸ§© Partition Logic:

* Use two pointers
* Swap elements to ensure correct pivot placement

---

## ğŸ”š Summary (Bullet Format):

* **Selection Sort:**

  * Select minimum each time, place at start
  * Time: O(nÂ²), Space: O(1)
  * Example: `[64, 25, 12, 22, 11] â†’ [11, 12, 22, 25, 64]`

* **Insertion Sort:**

  * Pick current and insert in sorted left part
  * Time: O(nÂ²), Best case O(n) if sorted
  * Space: O(1)
  * Shifts elements > key

* **Bubble Sort:**

  * Adjacent swaps, largest â€œbubblesâ€ to end
  * Time: O(nÂ²), Best O(n) with flag
  * Space: O(1)
  * Multiple passes

* **Merge Sort:**

  * Divide & conquer; merge sorted subarrays
  * Time: O(n log n), Space: O(n)
  * Stable sort

* **Quick Sort:**

  * Divide by pivot; partition into < and > subarrays
  * Time: O(n log n) avg, O(nÂ²) worst
  * Space: O(log n) recursive
  * Faster than merge sort in practice for in-place

Let me know if you want me to implement any/all of these in Java with dry-run comments.
